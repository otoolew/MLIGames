//
// LogicalExpression.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace XMLRules
{
	public class LogicalExpression : Altova.Node
	{
		#region Forward constructors
		public LogicalExpression() : base() { SetCollectionParents(); }
		public LogicalExpression(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public LogicalExpression(XmlNode node) : base(node) { SetCollectionParents(); }
		public LogicalExpression(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Element, "", "Unary");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Unary", i);
				InternalAdjustPrefix(DOMNode, true);
				new UnaryType(DOMNode).AdjustPrefix();
			}

			nCount = DomChildCount(NodeType.Element, "", "Relational");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Relational", i);
				InternalAdjustPrefix(DOMNode, true);
				new RelationalType(DOMNode).AdjustPrefix();
			}

			nCount = DomChildCount(NodeType.Element, "", "Logical");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Logical", i);
				InternalAdjustPrefix(DOMNode, true);
				new LogicalType(DOMNode).AdjustPrefix();
			}

			nCount = DomChildCount(NodeType.Element, "", "Value");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Value", i);
				InternalAdjustPrefix(DOMNode, true);
				new Value(DOMNode).AdjustPrefix();
			}
		}


		#region Unary accessor methods
		public int GetUnaryMinCount()
		{
			return 1;
		}

		public int UnaryMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUnaryMaxCount()
		{
			return 1;
		}

		public int UnaryMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetUnaryCount()
		{
			return DomChildCount(NodeType.Element, "", "Unary");
		}

		public int UnaryCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Unary");
			}
		}

		public bool HasUnary()
		{
			return HasDomChild(NodeType.Element, "", "Unary");
		}

		public UnaryType GetUnaryAt(int index)
		{
			return new UnaryType(GetDomChildAt(NodeType.Element, "", "Unary", index));
		}

		public UnaryType GetUnary()
		{
			return GetUnaryAt(0);
		}

		public UnaryType Unary
		{
			get
			{
				return GetUnaryAt(0);
			}
		}

		public void RemoveUnaryAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Unary", index);
		}

		public void RemoveUnary()
		{
			while (HasUnary())
				RemoveUnaryAt(0);
		}

		public void AddUnary(UnaryType newValue)
		{
			AppendDomElement("", "Unary", newValue);
		}

		public void InsertUnaryAt(UnaryType newValue, int index)
		{
			InsertDomElementAt("", "Unary", index, newValue);
		}

		public void ReplaceUnaryAt(UnaryType newValue, int index)
		{
			ReplaceDomElementAt("", "Unary", index, newValue);
		}
		#endregion // Unary accessor methods

		#region Unary collection
        public UnaryCollection	MyUnarys = new UnaryCollection( );

        public class UnaryCollection: IEnumerable
        {
            LogicalExpression parent;
            public LogicalExpression Parent
			{
				set
				{
					parent = value;
				}
			}
			public UnaryEnumerator GetEnumerator() 
			{
				return new UnaryEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class UnaryEnumerator: IEnumerator 
        {
			int nIndex;
			LogicalExpression parent;
			public UnaryEnumerator(LogicalExpression par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.UnaryCount );
			}
			public UnaryType  Current 
			{
				get 
				{
					return(parent.GetUnaryAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Unary collection

		#region Relational accessor methods
		public int GetRelationalMinCount()
		{
			return 1;
		}

		public int RelationalMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetRelationalMaxCount()
		{
			return 1;
		}

		public int RelationalMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetRelationalCount()
		{
			return DomChildCount(NodeType.Element, "", "Relational");
		}

		public int RelationalCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Relational");
			}
		}

		public bool HasRelational()
		{
			return HasDomChild(NodeType.Element, "", "Relational");
		}

		public RelationalType GetRelationalAt(int index)
		{
			return new RelationalType(GetDomChildAt(NodeType.Element, "", "Relational", index));
		}

		public RelationalType GetRelational()
		{
			return GetRelationalAt(0);
		}

		public RelationalType Relational
		{
			get
			{
				return GetRelationalAt(0);
			}
		}

		public void RemoveRelationalAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Relational", index);
		}

		public void RemoveRelational()
		{
			while (HasRelational())
				RemoveRelationalAt(0);
		}

		public void AddRelational(RelationalType newValue)
		{
			AppendDomElement("", "Relational", newValue);
		}

		public void InsertRelationalAt(RelationalType newValue, int index)
		{
			InsertDomElementAt("", "Relational", index, newValue);
		}

		public void ReplaceRelationalAt(RelationalType newValue, int index)
		{
			ReplaceDomElementAt("", "Relational", index, newValue);
		}
		#endregion // Relational accessor methods

		#region Relational collection
        public RelationalCollection	MyRelationals = new RelationalCollection( );

        public class RelationalCollection: IEnumerable
        {
            LogicalExpression parent;
            public LogicalExpression Parent
			{
				set
				{
					parent = value;
				}
			}
			public RelationalEnumerator GetEnumerator() 
			{
				return new RelationalEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class RelationalEnumerator: IEnumerator 
        {
			int nIndex;
			LogicalExpression parent;
			public RelationalEnumerator(LogicalExpression par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.RelationalCount );
			}
			public RelationalType  Current 
			{
				get 
				{
					return(parent.GetRelationalAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Relational collection

		#region Logical accessor methods
		public int GetLogicalMinCount()
		{
			return 1;
		}

		public int LogicalMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogicalMaxCount()
		{
			return 1;
		}

		public int LogicalMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogicalCount()
		{
			return DomChildCount(NodeType.Element, "", "Logical");
		}

		public int LogicalCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Logical");
			}
		}

		public bool HasLogical()
		{
			return HasDomChild(NodeType.Element, "", "Logical");
		}

		public LogicalType GetLogicalAt(int index)
		{
			return new LogicalType(GetDomChildAt(NodeType.Element, "", "Logical", index));
		}

		public LogicalType GetLogical()
		{
			return GetLogicalAt(0);
		}

		public LogicalType Logical
		{
			get
			{
				return GetLogicalAt(0);
			}
		}

		public void RemoveLogicalAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Logical", index);
		}

		public void RemoveLogical()
		{
			while (HasLogical())
				RemoveLogicalAt(0);
		}

		public void AddLogical(LogicalType newValue)
		{
			AppendDomElement("", "Logical", newValue);
		}

		public void InsertLogicalAt(LogicalType newValue, int index)
		{
			InsertDomElementAt("", "Logical", index, newValue);
		}

		public void ReplaceLogicalAt(LogicalType newValue, int index)
		{
			ReplaceDomElementAt("", "Logical", index, newValue);
		}
		#endregion // Logical accessor methods

		#region Logical collection
        public LogicalCollection	MyLogicals = new LogicalCollection( );

        public class LogicalCollection: IEnumerable
        {
            LogicalExpression parent;
            public LogicalExpression Parent
			{
				set
				{
					parent = value;
				}
			}
			public LogicalEnumerator GetEnumerator() 
			{
				return new LogicalEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LogicalEnumerator: IEnumerator 
        {
			int nIndex;
			LogicalExpression parent;
			public LogicalEnumerator(LogicalExpression par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LogicalCount );
			}
			public LogicalType  Current 
			{
				get 
				{
					return(parent.GetLogicalAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Logical collection

		#region Value accessor methods
		public int GetValueMinCount()
		{
			return 1;
		}

		public int ValueMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetValueMaxCount()
		{
			return 1;
		}

		public int ValueMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetValueCount()
		{
			return DomChildCount(NodeType.Element, "", "Value");
		}

		public int ValueCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Value");
			}
		}

		public bool HasValue()
		{
			return HasDomChild(NodeType.Element, "", "Value");
		}

		public Value GetValueAt(int index)
		{
			return new Value(GetDomChildAt(NodeType.Element, "", "Value", index));
		}

		public Value GetValue()
		{
			return GetValueAt(0);
		}

		public Value Value
		{
			get
			{
				return GetValueAt(0);
			}
		}

		public void RemoveValueAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Value", index);
		}

		public void RemoveValue()
		{
			while (HasValue())
				RemoveValueAt(0);
		}

		public void AddValue(Value newValue)
		{
			AppendDomElement("", "Value", newValue);
		}

		public void InsertValueAt(Value newValue, int index)
		{
			InsertDomElementAt("", "Value", index, newValue);
		}

		public void ReplaceValueAt(Value newValue, int index)
		{
			ReplaceDomElementAt("", "Value", index, newValue);
		}
		#endregion // Value accessor methods

		#region Value collection
        public ValueCollection	MyValues = new ValueCollection( );

        public class ValueCollection: IEnumerable
        {
            LogicalExpression parent;
            public LogicalExpression Parent
			{
				set
				{
					parent = value;
				}
			}
			public ValueEnumerator GetEnumerator() 
			{
				return new ValueEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ValueEnumerator: IEnumerator 
        {
			int nIndex;
			LogicalExpression parent;
			public ValueEnumerator(LogicalExpression par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ValueCount );
			}
			public Value  Current 
			{
				get 
				{
					return(parent.GetValueAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Value collection

        private void SetCollectionParents()
        {
            MyUnarys.Parent = this; 
            MyRelationals.Parent = this; 
            MyLogicals.Parent = this; 
            MyValues.Parent = this; 
	}
}
}
