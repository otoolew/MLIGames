//
// ArithemticOperator.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace XMLRules
{
	public class ArithemticOperator : Altova.Node
	{
		#region Forward constructors
		public ArithemticOperator() : base() { SetCollectionParents(); }
		public ArithemticOperator(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public ArithemticOperator(XmlNode node) : base(node) { SetCollectionParents(); }
		public ArithemticOperator(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Element, "", "Add");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Add", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "Subtract");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Subtract", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "Divide");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Divide", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "Multiply");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Multiply", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "Power");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Power", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "Log");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Log", i);
				InternalAdjustPrefix(DOMNode, true);
			}
		}


		#region Add accessor methods
		public int GetAddMinCount()
		{
			return 1;
		}

		public int AddMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetAddMaxCount()
		{
			return 1;
		}

		public int AddMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetAddCount()
		{
			return DomChildCount(NodeType.Element, "", "Add");
		}

		public int AddCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Add");
			}
		}

		public bool HasAdd()
		{
			return HasDomChild(NodeType.Element, "", "Add");
		}

		public SchemaString GetAddAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Add", index)));
		}

		public SchemaString GetAdd()
		{
			return GetAddAt(0);
		}

		public SchemaString Add
		{
			get
			{
				return GetAddAt(0);
			}
		}

		public void RemoveAddAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Add", index);
		}

		public void RemoveAdd()
		{
			while (HasAdd())
				RemoveAddAt(0);
		}

		public void AddAdd(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Add", newValue.ToString());
		}

		public void InsertAddAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Add", index, newValue.ToString());
		}

		public void ReplaceAddAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Add", index, newValue.ToString());
		}
		#endregion // Add accessor methods

		#region Add collection
        public AddCollection	MyAdds = new AddCollection( );

        public class AddCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public AddEnumerator GetEnumerator() 
			{
				return new AddEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class AddEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public AddEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.AddCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetAddAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Add collection

		#region Subtract accessor methods
		public int GetSubtractMinCount()
		{
			return 1;
		}

		public int SubtractMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetSubtractMaxCount()
		{
			return 1;
		}

		public int SubtractMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetSubtractCount()
		{
			return DomChildCount(NodeType.Element, "", "Subtract");
		}

		public int SubtractCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Subtract");
			}
		}

		public bool HasSubtract()
		{
			return HasDomChild(NodeType.Element, "", "Subtract");
		}

		public SchemaString GetSubtractAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Subtract", index)));
		}

		public SchemaString GetSubtract()
		{
			return GetSubtractAt(0);
		}

		public SchemaString Subtract
		{
			get
			{
				return GetSubtractAt(0);
			}
		}

		public void RemoveSubtractAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Subtract", index);
		}

		public void RemoveSubtract()
		{
			while (HasSubtract())
				RemoveSubtractAt(0);
		}

		public void AddSubtract(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Subtract", newValue.ToString());
		}

		public void InsertSubtractAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Subtract", index, newValue.ToString());
		}

		public void ReplaceSubtractAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Subtract", index, newValue.ToString());
		}
		#endregion // Subtract accessor methods

		#region Subtract collection
        public SubtractCollection	MySubtracts = new SubtractCollection( );

        public class SubtractCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public SubtractEnumerator GetEnumerator() 
			{
				return new SubtractEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class SubtractEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public SubtractEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.SubtractCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetSubtractAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Subtract collection

		#region Divide accessor methods
		public int GetDivideMinCount()
		{
			return 1;
		}

		public int DivideMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDivideMaxCount()
		{
			return 1;
		}

		public int DivideMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDivideCount()
		{
			return DomChildCount(NodeType.Element, "", "Divide");
		}

		public int DivideCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Divide");
			}
		}

		public bool HasDivide()
		{
			return HasDomChild(NodeType.Element, "", "Divide");
		}

		public SchemaString GetDivideAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Divide", index)));
		}

		public SchemaString GetDivide()
		{
			return GetDivideAt(0);
		}

		public SchemaString Divide
		{
			get
			{
				return GetDivideAt(0);
			}
		}

		public void RemoveDivideAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Divide", index);
		}

		public void RemoveDivide()
		{
			while (HasDivide())
				RemoveDivideAt(0);
		}

		public void AddDivide(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Divide", newValue.ToString());
		}

		public void InsertDivideAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Divide", index, newValue.ToString());
		}

		public void ReplaceDivideAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Divide", index, newValue.ToString());
		}
		#endregion // Divide accessor methods

		#region Divide collection
        public DivideCollection	MyDivides = new DivideCollection( );

        public class DivideCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public DivideEnumerator GetEnumerator() 
			{
				return new DivideEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DivideEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public DivideEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DivideCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetDivideAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Divide collection

		#region Multiply accessor methods
		public int GetMultiplyMinCount()
		{
			return 1;
		}

		public int MultiplyMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetMultiplyMaxCount()
		{
			return 1;
		}

		public int MultiplyMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetMultiplyCount()
		{
			return DomChildCount(NodeType.Element, "", "Multiply");
		}

		public int MultiplyCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Multiply");
			}
		}

		public bool HasMultiply()
		{
			return HasDomChild(NodeType.Element, "", "Multiply");
		}

		public SchemaString GetMultiplyAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Multiply", index)));
		}

		public SchemaString GetMultiply()
		{
			return GetMultiplyAt(0);
		}

		public SchemaString Multiply
		{
			get
			{
				return GetMultiplyAt(0);
			}
		}

		public void RemoveMultiplyAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Multiply", index);
		}

		public void RemoveMultiply()
		{
			while (HasMultiply())
				RemoveMultiplyAt(0);
		}

		public void AddMultiply(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Multiply", newValue.ToString());
		}

		public void InsertMultiplyAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Multiply", index, newValue.ToString());
		}

		public void ReplaceMultiplyAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Multiply", index, newValue.ToString());
		}
		#endregion // Multiply accessor methods

		#region Multiply collection
        public MultiplyCollection	MyMultiplys = new MultiplyCollection( );

        public class MultiplyCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public MultiplyEnumerator GetEnumerator() 
			{
				return new MultiplyEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class MultiplyEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public MultiplyEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.MultiplyCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetMultiplyAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Multiply collection

		#region Power accessor methods
		public int GetPowerMinCount()
		{
			return 1;
		}

		public int PowerMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPowerMaxCount()
		{
			return 1;
		}

		public int PowerMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPowerCount()
		{
			return DomChildCount(NodeType.Element, "", "Power");
		}

		public int PowerCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Power");
			}
		}

		public bool HasPower()
		{
			return HasDomChild(NodeType.Element, "", "Power");
		}

		public SchemaString GetPowerAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Power", index)));
		}

		public SchemaString GetPower()
		{
			return GetPowerAt(0);
		}

		public SchemaString Power
		{
			get
			{
				return GetPowerAt(0);
			}
		}

		public void RemovePowerAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Power", index);
		}

		public void RemovePower()
		{
			while (HasPower())
				RemovePowerAt(0);
		}

		public void AddPower(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Power", newValue.ToString());
		}

		public void InsertPowerAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Power", index, newValue.ToString());
		}

		public void ReplacePowerAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Power", index, newValue.ToString());
		}
		#endregion // Power accessor methods

		#region Power collection
        public PowerCollection	MyPowers = new PowerCollection( );

        public class PowerCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public PowerEnumerator GetEnumerator() 
			{
				return new PowerEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class PowerEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public PowerEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.PowerCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetPowerAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Power collection

		#region Log accessor methods
		public int GetLogMinCount()
		{
			return 1;
		}

		public int LogMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogMaxCount()
		{
			return 1;
		}

		public int LogMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogCount()
		{
			return DomChildCount(NodeType.Element, "", "Log");
		}

		public int LogCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Log");
			}
		}

		public bool HasLog()
		{
			return HasDomChild(NodeType.Element, "", "Log");
		}

		public SchemaString GetLogAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Log", index)));
		}

		public SchemaString GetLog()
		{
			return GetLogAt(0);
		}

		public SchemaString Log
		{
			get
			{
				return GetLogAt(0);
			}
		}

		public void RemoveLogAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Log", index);
		}

		public void RemoveLog()
		{
			while (HasLog())
				RemoveLogAt(0);
		}

		public void AddLog(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Log", newValue.ToString());
		}

		public void InsertLogAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Log", index, newValue.ToString());
		}

		public void ReplaceLogAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Log", index, newValue.ToString());
		}
		#endregion // Log accessor methods

		#region Log collection
        public LogCollection	MyLogs = new LogCollection( );

        public class LogCollection: IEnumerable
        {
            ArithemticOperator parent;
            public ArithemticOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public LogEnumerator GetEnumerator() 
			{
				return new LogEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LogEnumerator: IEnumerator 
        {
			int nIndex;
			ArithemticOperator parent;
			public LogEnumerator(ArithemticOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LogCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetLogAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Log collection

        private void SetCollectionParents()
        {
            MyAdds.Parent = this; 
            MySubtracts.Parent = this; 
            MyDivides.Parent = this; 
            MyMultiplys.Parent = this; 
            MyPowers.Parent = this; 
            MyLogs.Parent = this; 
	}
}
}
