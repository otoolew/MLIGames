//
// RelationalOperator.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace XMLRules
{
	public class RelationalOperator : Altova.Node
	{
		#region Forward constructors
		public RelationalOperator() : base() { SetCollectionParents(); }
		public RelationalOperator(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public RelationalOperator(XmlNode node) : base(node) { SetCollectionParents(); }
		public RelationalOperator(Altova.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{
			int nCount;

			nCount = DomChildCount(NodeType.Element, "", "Equals");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Equals", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "NotEquals");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "NotEquals", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "PartOf");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "PartOf", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "NotPartOf");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "NotPartOf", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "LessThan");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "LessThan", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "LessThanOrEquals");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "LessThanOrEquals", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "GreaterThan");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "GreaterThan", i);
				InternalAdjustPrefix(DOMNode, true);
			}

			nCount = DomChildCount(NodeType.Element, "", "GreaterThanOrEquals");
			for (int i = 0; i < nCount; i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "GreaterThanOrEquals", i);
				InternalAdjustPrefix(DOMNode, true);
			}
		}


		#region Equals accessor methods
		public int GetEqualsMinCount()
		{
			return 1;
		}

		public int EqualsMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetEqualsMaxCount()
		{
			return 1;
		}

		public int EqualsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetEqualsCount()
		{
			return DomChildCount(NodeType.Element, "", "Equals");
		}

		public int EqualsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Equals");
			}
		}

		public bool HasEquals()
		{
			return HasDomChild(NodeType.Element, "", "Equals");
		}

		public SchemaString GetEqualsAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "Equals", index)));
		}

		public SchemaString GetEquals()
		{
			return GetEqualsAt(0);
		}

		public SchemaString Equals
		{
			get
			{
				return GetEqualsAt(0);
			}
		}

		public void RemoveEqualsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Equals", index);
		}

		public void RemoveEquals()
		{
			while (HasEquals())
				RemoveEqualsAt(0);
		}

		public void AddEquals(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "Equals", newValue.ToString());
		}

		public void InsertEqualsAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "Equals", index, newValue.ToString());
		}

		public void ReplaceEqualsAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "Equals", index, newValue.ToString());
		}
		#endregion // Equals accessor methods

		#region Equals collection
        public EqualsCollection	MyEqualss = new EqualsCollection( );

        public class EqualsCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public EqualsEnumerator GetEnumerator() 
			{
				return new EqualsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class EqualsEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public EqualsEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.EqualsCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetEqualsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // Equals collection

		#region NotEquals accessor methods
		public int GetNotEqualsMinCount()
		{
			return 1;
		}

		public int NotEqualsMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNotEqualsMaxCount()
		{
			return 1;
		}

		public int NotEqualsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNotEqualsCount()
		{
			return DomChildCount(NodeType.Element, "", "NotEquals");
		}

		public int NotEqualsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "NotEquals");
			}
		}

		public bool HasNotEquals()
		{
			return HasDomChild(NodeType.Element, "", "NotEquals");
		}

		public SchemaString GetNotEqualsAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "NotEquals", index)));
		}

		public SchemaString GetNotEquals()
		{
			return GetNotEqualsAt(0);
		}

		public SchemaString NotEquals
		{
			get
			{
				return GetNotEqualsAt(0);
			}
		}

		public void RemoveNotEqualsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "NotEquals", index);
		}

		public void RemoveNotEquals()
		{
			while (HasNotEquals())
				RemoveNotEqualsAt(0);
		}

		public void AddNotEquals(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "NotEquals", newValue.ToString());
		}

		public void InsertNotEqualsAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "NotEquals", index, newValue.ToString());
		}

		public void ReplaceNotEqualsAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "NotEquals", index, newValue.ToString());
		}
		#endregion // NotEquals accessor methods

		#region NotEquals collection
        public NotEqualsCollection	MyNotEqualss = new NotEqualsCollection( );

        public class NotEqualsCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public NotEqualsEnumerator GetEnumerator() 
			{
				return new NotEqualsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class NotEqualsEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public NotEqualsEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.NotEqualsCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetNotEqualsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // NotEquals collection

		#region PartOf accessor methods
		public int GetPartOfMinCount()
		{
			return 1;
		}

		public int PartOfMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPartOfMaxCount()
		{
			return 1;
		}

		public int PartOfMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPartOfCount()
		{
			return DomChildCount(NodeType.Element, "", "PartOf");
		}

		public int PartOfCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "PartOf");
			}
		}

		public bool HasPartOf()
		{
			return HasDomChild(NodeType.Element, "", "PartOf");
		}

		public SchemaString GetPartOfAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "PartOf", index)));
		}

		public SchemaString GetPartOf()
		{
			return GetPartOfAt(0);
		}

		public SchemaString PartOf
		{
			get
			{
				return GetPartOfAt(0);
			}
		}

		public void RemovePartOfAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "PartOf", index);
		}

		public void RemovePartOf()
		{
			while (HasPartOf())
				RemovePartOfAt(0);
		}

		public void AddPartOf(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "PartOf", newValue.ToString());
		}

		public void InsertPartOfAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "PartOf", index, newValue.ToString());
		}

		public void ReplacePartOfAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "PartOf", index, newValue.ToString());
		}
		#endregion // PartOf accessor methods

		#region PartOf collection
        public PartOfCollection	MyPartOfs = new PartOfCollection( );

        public class PartOfCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public PartOfEnumerator GetEnumerator() 
			{
				return new PartOfEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class PartOfEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public PartOfEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.PartOfCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetPartOfAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // PartOf collection

		#region NotPartOf accessor methods
		public int GetNotPartOfMinCount()
		{
			return 1;
		}

		public int NotPartOfMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNotPartOfMaxCount()
		{
			return 1;
		}

		public int NotPartOfMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetNotPartOfCount()
		{
			return DomChildCount(NodeType.Element, "", "NotPartOf");
		}

		public int NotPartOfCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "NotPartOf");
			}
		}

		public bool HasNotPartOf()
		{
			return HasDomChild(NodeType.Element, "", "NotPartOf");
		}

		public SchemaString GetNotPartOfAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "NotPartOf", index)));
		}

		public SchemaString GetNotPartOf()
		{
			return GetNotPartOfAt(0);
		}

		public SchemaString NotPartOf
		{
			get
			{
				return GetNotPartOfAt(0);
			}
		}

		public void RemoveNotPartOfAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "NotPartOf", index);
		}

		public void RemoveNotPartOf()
		{
			while (HasNotPartOf())
				RemoveNotPartOfAt(0);
		}

		public void AddNotPartOf(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "NotPartOf", newValue.ToString());
		}

		public void InsertNotPartOfAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "NotPartOf", index, newValue.ToString());
		}

		public void ReplaceNotPartOfAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "NotPartOf", index, newValue.ToString());
		}
		#endregion // NotPartOf accessor methods

		#region NotPartOf collection
        public NotPartOfCollection	MyNotPartOfs = new NotPartOfCollection( );

        public class NotPartOfCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public NotPartOfEnumerator GetEnumerator() 
			{
				return new NotPartOfEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class NotPartOfEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public NotPartOfEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.NotPartOfCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetNotPartOfAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // NotPartOf collection

		#region LessThan accessor methods
		public int GetLessThanMinCount()
		{
			return 1;
		}

		public int LessThanMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLessThanMaxCount()
		{
			return 1;
		}

		public int LessThanMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLessThanCount()
		{
			return DomChildCount(NodeType.Element, "", "LessThan");
		}

		public int LessThanCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "LessThan");
			}
		}

		public bool HasLessThan()
		{
			return HasDomChild(NodeType.Element, "", "LessThan");
		}

		public SchemaString GetLessThanAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "LessThan", index)));
		}

		public SchemaString GetLessThan()
		{
			return GetLessThanAt(0);
		}

		public SchemaString LessThan
		{
			get
			{
				return GetLessThanAt(0);
			}
		}

		public void RemoveLessThanAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "LessThan", index);
		}

		public void RemoveLessThan()
		{
			while (HasLessThan())
				RemoveLessThanAt(0);
		}

		public void AddLessThan(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "LessThan", newValue.ToString());
		}

		public void InsertLessThanAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "LessThan", index, newValue.ToString());
		}

		public void ReplaceLessThanAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "LessThan", index, newValue.ToString());
		}
		#endregion // LessThan accessor methods

		#region LessThan collection
        public LessThanCollection	MyLessThans = new LessThanCollection( );

        public class LessThanCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public LessThanEnumerator GetEnumerator() 
			{
				return new LessThanEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LessThanEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public LessThanEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LessThanCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetLessThanAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // LessThan collection

		#region LessThanOrEquals accessor methods
		public int GetLessThanOrEqualsMinCount()
		{
			return 1;
		}

		public int LessThanOrEqualsMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLessThanOrEqualsMaxCount()
		{
			return 1;
		}

		public int LessThanOrEqualsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLessThanOrEqualsCount()
		{
			return DomChildCount(NodeType.Element, "", "LessThanOrEquals");
		}

		public int LessThanOrEqualsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "LessThanOrEquals");
			}
		}

		public bool HasLessThanOrEquals()
		{
			return HasDomChild(NodeType.Element, "", "LessThanOrEquals");
		}

		public SchemaString GetLessThanOrEqualsAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "LessThanOrEquals", index)));
		}

		public SchemaString GetLessThanOrEquals()
		{
			return GetLessThanOrEqualsAt(0);
		}

		public SchemaString LessThanOrEquals
		{
			get
			{
				return GetLessThanOrEqualsAt(0);
			}
		}

		public void RemoveLessThanOrEqualsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "LessThanOrEquals", index);
		}

		public void RemoveLessThanOrEquals()
		{
			while (HasLessThanOrEquals())
				RemoveLessThanOrEqualsAt(0);
		}

		public void AddLessThanOrEquals(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "LessThanOrEquals", newValue.ToString());
		}

		public void InsertLessThanOrEqualsAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "LessThanOrEquals", index, newValue.ToString());
		}

		public void ReplaceLessThanOrEqualsAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "LessThanOrEquals", index, newValue.ToString());
		}
		#endregion // LessThanOrEquals accessor methods

		#region LessThanOrEquals collection
        public LessThanOrEqualsCollection	MyLessThanOrEqualss = new LessThanOrEqualsCollection( );

        public class LessThanOrEqualsCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public LessThanOrEqualsEnumerator GetEnumerator() 
			{
				return new LessThanOrEqualsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LessThanOrEqualsEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public LessThanOrEqualsEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LessThanOrEqualsCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetLessThanOrEqualsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // LessThanOrEquals collection

		#region GreaterThan accessor methods
		public int GetGreaterThanMinCount()
		{
			return 1;
		}

		public int GreaterThanMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetGreaterThanMaxCount()
		{
			return 1;
		}

		public int GreaterThanMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetGreaterThanCount()
		{
			return DomChildCount(NodeType.Element, "", "GreaterThan");
		}

		public int GreaterThanCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "GreaterThan");
			}
		}

		public bool HasGreaterThan()
		{
			return HasDomChild(NodeType.Element, "", "GreaterThan");
		}

		public SchemaString GetGreaterThanAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "GreaterThan", index)));
		}

		public SchemaString GetGreaterThan()
		{
			return GetGreaterThanAt(0);
		}

		public SchemaString GreaterThan
		{
			get
			{
				return GetGreaterThanAt(0);
			}
		}

		public void RemoveGreaterThanAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "GreaterThan", index);
		}

		public void RemoveGreaterThan()
		{
			while (HasGreaterThan())
				RemoveGreaterThanAt(0);
		}

		public void AddGreaterThan(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "GreaterThan", newValue.ToString());
		}

		public void InsertGreaterThanAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "GreaterThan", index, newValue.ToString());
		}

		public void ReplaceGreaterThanAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "GreaterThan", index, newValue.ToString());
		}
		#endregion // GreaterThan accessor methods

		#region GreaterThan collection
        public GreaterThanCollection	MyGreaterThans = new GreaterThanCollection( );

        public class GreaterThanCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public GreaterThanEnumerator GetEnumerator() 
			{
				return new GreaterThanEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class GreaterThanEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public GreaterThanEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.GreaterThanCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetGreaterThanAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // GreaterThan collection

		#region GreaterThanOrEquals accessor methods
		public int GetGreaterThanOrEqualsMinCount()
		{
			return 1;
		}

		public int GreaterThanOrEqualsMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetGreaterThanOrEqualsMaxCount()
		{
			return 1;
		}

		public int GreaterThanOrEqualsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetGreaterThanOrEqualsCount()
		{
			return DomChildCount(NodeType.Element, "", "GreaterThanOrEquals");
		}

		public int GreaterThanOrEqualsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "GreaterThanOrEquals");
			}
		}

		public bool HasGreaterThanOrEquals()
		{
			return HasDomChild(NodeType.Element, "", "GreaterThanOrEquals");
		}

		public SchemaString GetGreaterThanOrEqualsAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Element, "", "GreaterThanOrEquals", index)));
		}

		public SchemaString GetGreaterThanOrEquals()
		{
			return GetGreaterThanOrEqualsAt(0);
		}

		public SchemaString GreaterThanOrEquals
		{
			get
			{
				return GetGreaterThanOrEqualsAt(0);
			}
		}

		public void RemoveGreaterThanOrEqualsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "GreaterThanOrEquals", index);
		}

		public void RemoveGreaterThanOrEquals()
		{
			while (HasGreaterThanOrEquals())
				RemoveGreaterThanOrEqualsAt(0);
		}

		public void AddGreaterThanOrEquals(SchemaString newValue)
		{
			AppendDomChild(NodeType.Element, "", "GreaterThanOrEquals", newValue.ToString());
		}

		public void InsertGreaterThanOrEqualsAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Element, "", "GreaterThanOrEquals", index, newValue.ToString());
		}

		public void ReplaceGreaterThanOrEqualsAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Element, "", "GreaterThanOrEquals", index, newValue.ToString());
		}
		#endregion // GreaterThanOrEquals accessor methods

		#region GreaterThanOrEquals collection
        public GreaterThanOrEqualsCollection	MyGreaterThanOrEqualss = new GreaterThanOrEqualsCollection( );

        public class GreaterThanOrEqualsCollection: IEnumerable
        {
            RelationalOperator parent;
            public RelationalOperator Parent
			{
				set
				{
					parent = value;
				}
			}
			public GreaterThanOrEqualsEnumerator GetEnumerator() 
			{
				return new GreaterThanOrEqualsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class GreaterThanOrEqualsEnumerator: IEnumerator 
        {
			int nIndex;
			RelationalOperator parent;
			public GreaterThanOrEqualsEnumerator(RelationalOperator par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.GreaterThanOrEqualsCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.GetGreaterThanOrEqualsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}
	
        #endregion // GreaterThanOrEquals collection

        private void SetCollectionParents()
        {
            MyEqualss.Parent = this; 
            MyNotEqualss.Parent = this; 
            MyPartOfs.Parent = this; 
            MyNotPartOfs.Parent = this; 
            MyLessThans.Parent = this; 
            MyLessThanOrEqualss.Parent = this; 
            MyGreaterThans.Parent = this; 
            MyGreaterThanOrEqualss.Parent = this; 
	}
}
}
